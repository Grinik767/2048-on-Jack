class Board {
    field Array board;
    field Random rnd;

    method Array getValues () {
        return board;
    }

    constructor Board new(){
        // иницилизируем игровое поле
        var int i, j, x;
        var Array xi, rndNumbers;
        let rnd = Random.new(13);
        let rndNumbers = rnd.getTwoRandomNumbers(0, 15);
        let board = Array.new(4);
        let i = 0;
        while (i < 4){
            let board[i] = Array.new(4);
            let j = 0;
            while (j < 4){
                let xi = board[i];
                let x = i * 4 + MathAddon.getRemainder(j, 4);
                if (x = rndNumbers[0]){
                    let xi[j] = Tile.new(2);
                } else {
                    if (x = rndNumbers[1]){
                        let xi[j] = Tile.new(2);
                    } else{
                        let xi[j] = Tile.new(0);
                    }
                }
                let j = j + 1; 
            }
            let i = i + 1;
        }
        return this;
    }

    method Array getFreePlaces () {
        /*
        индексация свободных мест
        0 1 2 3
        4 5 6 7...
        */
        var Array list, result, xi;
        var int i, j, k;
        var Tile xj;
        let list = Array.new(16);
        let i = 0;
        let k = 0;
        while (i < 4){
            let j = 0;
            while (j < 4){
                let xi = board[i];
                let xj = xi[j];
                if (xj.getValue() = 0){
                    let list[k] = i * 4 + MathAddon.getRemainder(j, 4);
                    let k = k + 1;
                }
                let j = j + 1;
            }
            let i = i + 1;
        }
        let result = Array.new(2);
        let result[0] = list;
        let result[1] = k;
        return result;
    }

    method void CalculateLineTurnRight(Array line){
        var int i, xC, xN, kZero, kNotZero, cur;
        var Tile tC, tN;
        var Array resultNoZero, result, resultWithAdd;

        let resultNoZero = ArrayAddon.getNoZeroElements(line);
        let result = resultNoZero[0];
        let kNotZero = resultNoZero[1];
        let kZero = 4 - kNotZero;

        let i = 0;
        let resultWithAdd = Array.new(4);
        let cur = 0;
        while (i < kNotZero){
            let tC = result[i];
            let xC = tC.getValue();
            if (~(i + 1 = kNotZero)){
                let tN = result[i + 1];
                let xN = tN.getValue();
                if (xC = xN){
                    let resultWithAdd[cur] = tN.Add(tC);
                    let i = i + 1;
                    let kZero = kZero + 1; 
                } else {
                    let resultWithAdd[cur] = Tile.new(xC);
                }
            } else {
                let resultWithAdd[cur] = Tile.new(xC);
            }
            let cur = cur + 1;
            let i = i + 1;
        }
        do result.dispose();

        let i = 0;
        while (i < 4){
            let tC = line[i];
            do tC.dispose();
            if (i < kZero){
                let line[i] = Tile.new(0);
            }
            else {
                let tC = resultWithAdd[i - kZero];
                let line[i] = Tile.new(tC.getValue());
            }
            let xN = line[i];
            let i = i + 1;
        }

        do resultWithAdd.dispose();
        do resultNoZero.dispose();
    
        return;
    }

    method bool MakeStepHorizontal(bool isTurnLeft) {
        var int i, kFreePlaces, rndPlace;
        var Tile newTile;
        var Array places_, freePlacesIndxs, line, el;
        
        let i = 0;
        while (i < 4){
            if (isTurnLeft = true){
                do ArrayAddon.reverseArray(board[i]);
            }
            do CalculateLineTurnRight(board[i]);
            let i = i + 1;
        }

        let i = 0;
        while ((i < 4) & isTurnLeft){
            do ArrayAddon.reverseArray(board[i]);
            let i = i + 1;
        }

        let places_ = getFreePlaces();
        let freePlacesIndxs = places_[0];
        let kFreePlaces = places_[1];

        if (kFreePlaces = 0){
            return false;
        }
        
        let rndPlace = freePlacesIndxs[rnd.nextRandom(0, kFreePlaces - 1)];
        if (rnd.nextRandom(0, 100) < 90){
            let newTile = Tile.new(2);
        } else {
            let newTile = Tile.new(4);
        }
        let line = board[rndPlace / 4];
        let el = line[MathAddon.getRemainder(rndPlace, 4)];
        do el.dispose();
        let line[MathAddon.getRemainder(rndPlace, 4)] = newTile;
        
        return true;
    }

    method bool MakeStepVertical(bool isUp) {
        var bool wereFreePlaces;
        do ArrayAddon.TransposeMatrix(board);
        if (isUp = true){
            let wereFreePlaces = MakeStepHorizontal(true);
        }
        if (isUp = false) {
            let wereFreePlaces = MakeStepHorizontal(false);
        }
        do ArrayAddon.TransposeMatrix(board);
        if (wereFreePlaces = false) {
            return false;
        }
        return true;

    }


    method void dispose () {
        do board.dispose();
        do Memory.deAlloc(this);
        return;
    }
}